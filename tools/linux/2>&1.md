经常可以在一些脚本，尤其是在crontab调用时发现如下形式的命令调用

`/tmp/test.sh > /tmp/test.log 2>&1`
前半部分`/tmp/test.sh > /tmp/test.log`很容易理解，那么后面的`2>&1`是怎么回事呢？

要解释这个问题，还是得提到文件重定向。我们知道>和<是文件重定向符。那么1和2是什么？在shell中，每个进程都和三个系统文件相关联：标准输入stdin，标准输出stdout和标准错误stderr，三个系统文件的文件描述符分别为0，1和2。所以这里2>&1 的意思就是将标准错误也输出到标准输出当中。

下面通过一个例子来展示`2>&1`有什么作用：
```sh
$ cat test.sh
t
date
```
`test.sh`中包含两个命令，其中`t`是一个不存在的命令，执行会报错，默认情况下，错误会输出到stderr。`date`则能正确执行，并且输出时间信息，默认输出到stdout
```sh
./test.sh > test1.log
./test.sh: line 1: t: command not found

$ cat test1.log
Tue Oct 9 20:51:50 CST 2007
```
可以看到，date的执行结果被重定向到log文件中了，而t无法执行的错误则只打印在屏幕上。
```sh
$ ./test.sh > test2.log 2>&1
$ cat test2.log
./test.sh: line 1: t: command not found
Tue Oct 9 20:53:44 CST 2007
```
这次，stderr和stdout的内容都被重定向到log文件中了。

实际上， `>` 就相当于` 1>` 也就是重定向标准输出，不包括标准错误。通过`2>&1`，就将标准错误重定向到标准输出了，那么再使用`>`重定向就会将标准输出和标准错误信息一同重定向了。如果只想重定向标准错误到文件中，则可以使用2> file。

linux shell 中`"2>&1"`含义

脚本是:
     nohup /mnt/Nand3/H2000G >/dev/null 2>&1 &
     
     对于& 1 更准确的说应该是文件描述符 1,而1 一般代表的就是STDOUT_FILENO,实际上这个操作就是一个dup2(2)调用.他标准输出到all_result ,然后复制标准输出到文件描述符2(STDERR_FILENO),其后果就是文件描述符1和2指向同一个文件表项,也可以说错误的输出被合并了.其中0 表示键盘输入 1表示屏幕输出 2表示错误输出.把标准出错重定向到标准输出,然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面。
     
     command >out.file 2>&1 &
     
     command >out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。 2>&1 是将标准出错重定向到标准输出，这里的标准输出已经重定向到了out.file文件，即将标准出错也输出到out.file文件中。最后一个& ， 是让该命令在后台执行。
    
     试想2>1代表什么，2与>结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；
换成2>&1，&与1结合就代表标准输出了，就变成错误重定向到标准输出.

     你可以用
           ls 2>1测试一下，不会报没有2文件的错误，但会输出一个空的文件1；
           ls xxx 2>1测试，没有xxx这个文件的错误输出到了1中；
           ls xxx 2>&1测试，不会生成1这个文件了，不过错误跑到标准输出了；
           ls xxx >out.txt 2>&1, 实际上可换成 ls xxx 1>out.txt 2>&1；重定向符号>默认是1,错误和输出都传到out.txt了。
     为何2>&1要写在后面？
     command > file 2>&1
      首先是command > file将标准输出重定向到file中， 2>&1 是标准错误拷贝了标准输出的行为，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。
     command 2>&1 >file
     2>&1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。>file 后输出才被重定向到file，但标准错误仍然保持在终端。

用strace可以看到：
1. command > file 2>&1
这个命令中实现重定向的关键系统调用序列是：
open(file) == 3
dup2(3,1)
dup2(1,2)

2. command 2>&1 >file
这个命令中实现重定向的关键系统调用序列是：
dup2(1,2)
open(file) == 3
dup2(3,1)
